<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: n3
  
    &mdash; Notation-3 and Turtle reader/writer for RDF.rb.
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "n3";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: n3</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'>
<pre class="code ruby"><code class="ruby"># EBNF Notation3 Grammar based pm Antlr4.
# From https://github.com/w3c/N3/blob/master/grammar/n3.g4

[1]  n3Doc                              ::= (n3Statement &#39;.&#39; | sparqlDirective)*

[2]  n3Statement                        ::= n3Directive | triples

[3]  n3Directive                        ::= prefixID | base

[4]  sparqlDirective                    ::= sparqlBase | sparqlPrefix

[5]  sparqlBase                         ::= BASE IRIREF

[6]  sparqlPrefix                       ::= PREFIX PNAME_NS IRIREF

[7]  prefixID                           ::= &#39;@prefix&#39; PNAME_NS IRIREF

[8]  base                               ::= &#39;@base&#39; IRIREF

[9]  triples                            ::= subject predicateObjectList?

[10] predicateObjectList                ::= verb objectList (&#39;;&#39; (verb objectList)?)*

[11] objectList                         ::= object (&#39;,&#39; object)*

[12] verb                               ::= predicate
                                          | &#39;a&#39;
                                          | &#39;has&#39; expression
                                          | &#39;is&#39; expression &#39;of&#39;
                                          | &#39;=&#39;
                                          | &#39;&lt;=&#39;
                                          | &#39;=&gt;&#39;

[13] subject                            ::= expression

[14] predicate                          ::= (expression | &#39;&lt;-&#39; expression)
                                            /* allow inverting first predicate in a path */

[15] object                             ::= expression

[16] expression                         ::= path

[17] path	                              ::= pathItem (&#39;!&#39; path | &#39;^&#39; path)?

[18] pathItem                           ::= iri
                                          | blankNode
                                          | quickVar
                                          | collection
                                          | blankNodePropertyList
                                          | iriPropertyList
                                          | literal
                                          | formula

[19] literal                            ::= rdfLiteral
                                          | numericLiteral
                                          | BOOLEAN_LITERAL

[20] blankNodePropertyList              ::= &#39;[&#39; predicateObjectList &#39;]&#39;

[21] iriPropertyList                    ::= IPLSTART iri predicateObjectList &#39;]&#39;

[22] collection                         ::= &#39;(&#39; object* &#39;)&#39;

[23] formula                            ::= &#39;{&#39; formulaContent? &#39;}&#39;

[24] formulaContent                     ::= n3Statement (&#39;.&#39; formulaContent?)?
                                          | sparqlDirective formulaContent?

[25] numericLiteral                     ::= DOUBLE | DECIMAL | INTEGER

[26] rdfLiteral                         ::= STRING (LANGTAG | &#39;^^&#39; iri)?

[27] iri                                ::= IRIREF | prefixedName

[28] prefixedName                       ::= PNAME_LN | PNAME_NS
                                            # PNAME_NS will be matched for &#39;:&#39; (i.e., &quot;empty&quot;) prefixedNames
                                            # hence this cannot be a lexer rule; for s/p/o of only &#39;:&#39;, PNAME_NS will be returned
                                            # instead of PrefixedName token

[29] blankNode                          ::=  BLANK_NODE_LABEL | ANON

[30] quickVar                           ::= QUICK_VAR_NAME
                                            # only made this a parser rule for consistency
                                            # (all other path-items are also parser rules)

@terminals

[31] BOOLEAN_LITERAL                    ::= &#39;true&#39; | &#39;false&#39;

[32] STRING                             ::= STRING_LITERAL_LONG_SINGLE_QUOTE
                                          | STRING_LITERAL_LONG_QUOTE
                                          | STRING_LITERAL_QUOTE
                                          | STRING_LITERAL_SINGLE_QUOTE

/* Note, this must be matched before &#39;[&#39; */
[33] IPLSTART                           ::= &#39;[&#39; WS* &#39;id&#39;

/* borrowed from SPARQL spec, which excludes newlines and other nastiness */
[139s] IRIREF                           ::= &#39;&lt;&#39; ([^&lt;&gt;&quot;{}|^`\]-[#x00-#x20] | UCHAR)* &#39;&gt;&#39;
[140s] PNAME_NS                         ::= PN_PREFIX? &#39;:&#39;
[141s] PNAME_LN                         ::= PNAME_NS PN_LOCAL
[142s] BLANK_NODE_LABEL                 ::= &#39;_:&#39; ( PN_CHARS_U | [0-9] ) ((PN_CHARS|&#39;.&#39;)* PN_CHARS)?
[145s] LANGTAG                          ::= &quot;@&quot; ([a-zA-Z]+ ( &quot;-&quot; [a-zA-Z0-9]+ )*)
[146s] INTEGER                          ::= [0-9]+
[147s] DECIMAL                          ::= [0-9]* &#39;.&#39; [0-9]+
[148s] DOUBLE                           ::= [0-9]+ &#39;.&#39; [0-9]* EXPONENT
                                          | &#39;.&#39; ([0-9])+ EXPONENT | ([0-9])+ EXPONENT
[155s] EXPONENT                         ::= [eE] [+-]? [0-9]+
[156s] STRING_LITERAL_QUOTE             ::= &#39;&quot;&#39; ( [^#x22#x5C#xA#xD] | ECHAR | UCHAR )* &#39;&quot;&#39;
[157s] STRING_LITERAL_SINGLE_QUOTE      ::= &quot;&#39;&quot; ( [^#x27#x5C#xA#xD] | ECHAR | UCHAR )* &quot;&#39;&quot;
[158s] STRING_LITERAL_LONG_SINGLE_QUOTE ::= &quot;&#39;&#39;&#39;&quot; ( ( &quot;&#39;&quot; | &quot;&#39;&#39;&quot; )? ( [^&#39;\] | ECHAR | UCHAR ) )* &quot;&#39;&#39;&#39;&quot;
[159s] STRING_LITERAL_LONG_QUOTE        ::= &#39;&quot;&quot;&quot;&#39; ( ( &#39;&quot;&#39; | &#39;&quot;&quot;&#39; )? ( [^&quot;\] | ECHAR | UCHAR ) )* &#39;&quot;&quot;&quot;&#39;
[35]  UCHAR                             ::=   ( &quot;\u&quot; HEX HEX HEX HEX ) | ( &quot;\U&quot; HEX HEX HEX HEX HEX HEX HEX HEX )
[160s] ECHAR                            ::= &quot;\&quot; [tbnrf\&quot;&#39;]
[162s] WS                               ::= #x20 | #x9 | #xD | #xA
[163s] ANON                             ::= &#39;[&#39; WS* &#39;]&#39;
[36] QUICK_VAR_NAME                     ::= &quot;?&quot; PN_LOCAL
                                           /* Allows fuller character set */
[164s] PN_CHARS_BASE                    ::= [A-Z] | [a-z] | [#x00C0-#x00D6]
                                          | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D]
                                          | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F]
                                          | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF]
                                          | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
[165s] PN_CHARS_U                     ::= PN_CHARS_BASE | &#39;_&#39;
[167s] PN_CHARS                       ::= PN_CHARS_U | &quot;-&quot; | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]
/* BASE and PREFIX must be case-insensitive, hence these monstrosities */
[37] BASE                             ::= (&#39;B&#39;|&#39;b&#39;) (&#39;A&#39;|&#39;a&#39;) (&#39;S&#39;|&#39;s&#39;) (&#39;E&#39;|&#39;e&#39;)
[38] PREFIX                           ::= (&#39;P&#39;|&#39;p&#39;) (&#39;R&#39;|&#39;r&#39;) (&#39;E&#39;|&#39;e&#39;) (&#39;F&#39;|&#39;f&#39;) (&#39;I&#39;|&#39;i&#39;) (&#39;X&#39;|&#39;x&#39;)
[168s] PN_PREFIX                      ::= PN_CHARS_BASE ( ( PN_CHARS | &quot;.&quot; )* PN_CHARS )?
[169s] PN_LOCAL                       ::= ( PN_CHARS_U | &#39;:&#39; | [0-9] | PLX ) ( ( PN_CHARS | &#39;.&#39; | &#39;:&#39; | PLX )*  ( PN_CHARS | &#39;:&#39; | PLX ) ) ?
[170s] PLX                            ::= PERCENT | PN_LOCAL_ESC
[171s] PERCENT                        ::= &#39;%&#39; HEX HEX
[172s] HEX                            ::=   [0-9] | [A-F] | [a-f]
[173s] PN_LOCAL_ESC                   ::= &#39;\&#39; ( &#39;_&#39; | &#39;~&#39; | &#39;.&#39; | &#39;-&#39; | &#39;!&#39; | &#39;$&#39; | &#39;&amp;&#39; | &quot;&#39;&quot; | &#39;(&#39; | &#39;)&#39; | &#39;*&#39; | &#39;+&#39; | &#39;,&#39; | &#39;;&#39; | &#39;=&#39;
                                        | &#39;/&#39; | &#39;?&#39; | &#39;#&#39; | &#39;@&#39; | &#39;%&#39; )
[39] COMMENT   ::= (&#39;#&#39; - &#39;#x&#39;) [^#xA#xC#xD]*

# Ignore all whitespace and comments between non-terminals
@pass           ( WS | COMMENT )*
</code></pre>
</div></div>

      <div id="footer">
  Generated on Fri Sep  1 20:37:16 2023 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.34 (ruby-3.1.4).
</div>

    </div>
  </body>
</html>